#ifndef __LASERPRUNER_H
#define __LASERPRUNER_H

#include <string>
#include <vector>
#include <map>
#include <cv.h>
#include "BDLPointGraph.h"
#include "LaserProjector.h"

/* A modified version of SimplePruner. It is used to prune a tree
 * after each branch replacement by a laser point could.
 * It also owns the point could, as in SimplePruner which owns an IplImage.
 * Usage 1:
 * 1. LaserPruner()
 * 2. setup() // for setting cloud
 * 3. is_inside()
 * 3. set_support() // for backward-growing
 *
 * Usage 2:
 * 1. LaserPruner()
 * 2. setup()
 * 3. segment_initial_branch()
 */
class LaserPruner
{
    public:
        LaserPruner();
        LaserPruner(bool verbose);
        ~LaserPruner();

        /* clear this instance
         */
        void clear();

        /* set the point cloud
         * sp_path: the file path of the laser data, in terms of sp format
         * cam_path: the file path of the camera data, generated by script 'extract_camera'
         * is_raw_sp: indicate if the sp_path points to a raw sp
         */
        void setup(std::string sp_path, std::string cam_path);
        
        /* ask if this instance is loaded
         */
        bool is_loaded();

        /* query by inspecting if line (prev-->node) crosses the boundary
         */
        bool is_inside(osg::Vec3 node, osg::Vec3 prev, osg::Vec3& hit, bool& hit_valid);

        /* query by inspecting if line (_cg-->node) crosses the boundary
         * hit: the point where the ray crosses the boundary
         */
        //bool is_inside(BDLSkeletonNode *node);
        bool is_inside(osg::Vec3 node, osg::Vec3& hit, bool& hit_valid);
        bool is_inside(osg::Vec3 node);

        /* use orthogonal projection
         */
        //bool is_inside_ortho(osg::Vec3 node);

        //this is exposed for calculating potential energy
        std::vector <osg::Vec3> _surface_pts;

        /* map Vec3 to an int key for _voxel_dict
         * return -1 if error occurs
         * note: should only be called after setup_cube_pruner()
         */
        int key(osg::Vec3 p);

        std::map <int, std::vector <int> > _voxel_dict;

        /* vote around the point p to set the _voxel_dict_supported to true
         * within a given range effect
         */
        void set_support(osg::Vec3 p, float scale = 0.5f);

        /* ray-trace and prune from all leaves point to the central core
         * until a non-empty voxel is hit
         */
        void back_trace_prune(BDLSkeletonNode *root);

        //for indicating which voxel is supported
        std::map <int, bool > _voxel_dict_supported;

        //the max key 
        int _upper;

        /* segment the raw points into foliage points and 
         * initial skeleton
         * foliage_path: the new file path of the segmented foliage points
         */
        std::vector <osg::Vec3> segment_initial_branch(std::string foliage_path);

        /* segment initial branch by plane sweep
         * return the initial points
         * and other foliage info
         */
        std::vector <osg::Vec3> segment_initial_branch_plane_sweep(std::vector <osg::Vec3>& foliage, std::vector <int>& pts_img, std::vector <osg::Vec2>& pts_uv, osg::Vec3& foliage_center, float& init_threshold);

        /* save the points as foliage simple points
         */
        void save_foliage(std::string foliage_path, std::vector <osg::Vec3> pts, std::vector <int> pts_img, std::vector <osg::Vec2> pts_uv);

    protected:
        /* bound's left, right, top, bottom, in, out
         */
        inline bool cloud_metrics(std::vector <osg::Vec3> data);

        /* mirror _raw_pts at the left-plane and put all points in _surface_pts
         */
        inline void mirror();

        /* only set the _surface_pts without mirroring
         */
        inline void set_surface_pts();

        /* cg of _surface_pts
         */
        inline osg::Vec3 find_cg(std::vector <osg::Vec3> data);

        /* find the x-plane where it is at 1 sd of the cg
         */
        inline void find_sd();

        /* setup the cube-pruner data structure
         * f(Vec3) --> key --> dict[key] --> vector <int> --> _surface_pts[index]
         * assume cloud_metrics returns true before calling
         */
        inline void setup_cube_pruner();

        /* for reading the segmentation by index to the _segmentations
         */
        inline int width(int index);
        inline int height(int index);
        inline uchar read(int index, int x, int y);

        /* after asking _projector to project 3D points to a view index,
         * use the un-texture coords to ask this method if it lies inside
         * the mask
         */
        inline bool is_inside_mask(int index, float x, float y, bool lenient = false);

    private:
        bool _verbose;
        std::vector <osg::Vec3> _raw_pts;
        std::vector <int> _pts_img;
        std::vector <osg::Vec2> _pts_uv;
        float _left, _right, _top, _bottom, _in, _out, _sd1;
        osg::Vec3 _cg;
        int _pruner_cube_step;//number of voxels along a dimension
        osg::Vec3 _origin; //the left-out-bottom-most corner of the volume
        osg::Vec3 _voxel;//actual step size of the volume
        float _ray_trace_step;//the step size of one ray tracing step

        //for querying if 3D points lies outside image mask
        // the cg of the original points in bdl, used for projection only
        osg::Vec3 _sp_cg; 
        LaserProjector _projector;
        std::vector <IplImage *> _segmentations;
};

#endif
