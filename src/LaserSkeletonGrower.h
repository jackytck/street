#ifndef __LASERSKELETONGROWER_H
#define __LASERSKELETONGROWER_H

#include <vector>
#include <string>
#include "Library.h"
#include "LibraryElement.h"
#include "LaserPruner.h"
#include "SimpleVolumeFloat.h"

/* This is a modified version of SimpleSkeletonGrower for laser data.
 * A simple skeleton grower used to grow a default skeleton by default
 * elements from the library. Brute force or back tracking approach
 * is used to obtain the orientation.
 * Usage:
 * 1. LaserSkeletonGrower()
 * 2. setup()
 * 3. set_initial_skeleton()
 * 4. grow()
 */

class LaserSkeletonGrower
{
    public:
        LaserSkeletonGrower();
        ~LaserSkeletonGrower();
        
        /* setup the paths of master elements, master skeletons, laser simple point and laser camera generated by script 'extract_camera'
         */
        void setup(std::string master_element, std::string master_skeleton, std::string laser_sp, std::string laser_cam, bool is_laser_raw = false);

        /* choose the k-th default skeleton in the library as the
         * initial skeleton for subsequent growing,
         * this will reload the surface points and set the new root
         */
        void set_initial_skeleton(int k);

        /* pick a branch from the tree to replace
		 * space_aware: if true, return the farest node from _surface, else use minimum generation
         * return the tail of the branch, its _prev_support points to its root
         */
        BDLSkeletonNode *pick_branch(bool space_aware = false);

        /* replace the branch with an library element and a certain rotation
         * branch_tail: the existing branch is defined by <branch_tail, branch_tail->_prev_support>
         * element: the library element
         * angle: the rotation angle along the branch
         * return all the sub-tree roots for pruning
         */
        std::vector <BDLSkeletonNode *> replace_branch(BDLSkeletonNode *branch_tail, LibraryElement element, int angle);

		/* for determining the optimal element and angle
		 * same as replace_branch but it will not change anything to existing _root
		 * note: need to manually delete the return values to prevent leaking
		 */
        std::vector <BDLSkeletonNode *> replace_branch_unchanged(BDLSkeletonNode *branch_tail, LibraryElement element, int angle);

        /* prune the sub_tree rooted at root
         */
        void prune(std::vector<BDLSkeletonNode *> roots);

        /* grow the tree by first pick_branch(), then replace_branch()
         * and finally prune()
		 * note: this is purely random
         */
        void grow(int no_branch);

		/* grow the tree by potential energy
		 */
		void grow_potential(int no_branch);

        /* grow the tree by minimizing the surface distance
         * this is only used for comparison in the paper only
         */
        void grow_exhaustive(int no_branch);
        float compute_energy(BDLSkeletonNode *root);

		/* backward growing
         * see descriptions in .cpp
		 */
		void backward_grow(bool dense = false);
        //void test_laser(std::string path);

        // the root of the tree
        BDLSkeletonNode *_root;
        // the library
        Library _library;
        //if >= threshold, then not too close (between two line segments)
        float _close_threshold;
        //float _k_d;

        //VolumeSurface _surface;

    protected:
        inline std::vector <BDLSkeletonNode *> bfs();
        inline void prune(BDLSkeletonNode *root);
        inline bool is_too_close(BDLSkeletonNode *node, BDLSkeletonNode *child);

		/* to compute the potential energy of the given tree with the given space
		 * return -1.0f if root is NULL
		 */
		inline float compute_potential_energy(BDLSkeletonNode *root, const SimpleVolumeFloat& space);
		inline float compute_potential_energy(std::vector <BDLSkeletonNode *> points, const SimpleVolumeFloat& space);

        /* prune the sub_tree rooted at root
         */
        inline std::vector <BDLSkeletonNode *> after_pruned(BDLSkeletonNode *root);
        inline std::vector <BDLSkeletonNode *> after_pruned(std::vector <BDLSkeletonNode *> roots);

    private:
        LaserPruner _pruner;
		bool _approaching_done; //for signaling the end of the growing stage
        float _fol_cut;//threshold between foliage and initial
};

#endif
